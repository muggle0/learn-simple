# 开篇语

作者：muggle

自用烤面经，勿外传

之前在公司做过一段时间面试官，公司的面试流程是：HR找简历，和候选人聊并索要简历 ---> 一面面试官筛选候选人简历 》 一面，记录候选人问答内容，打分 ---> 把一面记录交给研发组长，由研发组长负责二面 》 根据候选人定位职级安排三面（高职级才有三面）---> hr面，谈薪资。

在这里我分享下我做面试官的经验，公司一面二面都是线上面试，我负责的流程是一面，一般我会和另外一个小伙伴一起负责一面，因为相对而言二对一面试能给候选人带来比较大的压迫感，对一些心虚的候选人有比较好的压制力，不要小看这一点，屡试不爽。

第一点建议：从我的角度来说作为候选人一定要复习好技术点，要带着自信去面试，不要露怯。

在面试方面我们一般会提前根据候选人的项目经历问一些业务逻辑，然后根据业务中使用到的技术或设计方案进行提问，中途可能会结合我们自身类似的经历问一些问题。

第二点建议：项目经历要写好，项目经历从一定程度上对面试官的提问起到引导作用。

在问完项目相关的问题后基本上我们就会有个初步的打分了，基本上能答上来的给80分左右，答上来大部分卡壳比较多的60分，低于60分的基本上后面就是随便问问走走过场。
然后我们会问一些纯技术方面的问题，技术问题会根据候选人的技术栈进行提问，其实这个阶段也是面试官和候选人交流技术心得的阶段。
在这个阶段基本上对自己比较自信的候选人面对一些疑惑都会反过来问面试官问题，一般我们也会很乐意这种交流。这个阶段我们着重问的技术点是 redis mysql jvm，候选人如果能答上80%左右基本上就让过了。
我们问的问题基本上会尽量避免一些八股文，因为线上面试有很多候选人喜欢叫朋友帮忙百度，遇到过好几次，还有照着csdn念都念错的。

第三点建议：八股文可以背，但是要有自己的理解，把八股文的答案理解下来，而不是就纯粹的背答案。

第三阶段会问一些实践问题，这一环节更倾向于考虑对候选人是否加分。会结合候选人的项目经理问一些类似oom，高cpu使用率等事故进行提问，如果是被提前pass掉的候选人就不问这些了。
最后如果候选人项目的业务逻辑答的不是很好，但是技术面回答的还不错的我们定义为八股文选手，这种选手处于可过可不过的水平，会根据第三阶段的回答情况打80到85分。
如果候选人业务逻辑答的还可以，技术面不太行我们定义为老油条，一般是不给过的。如果业务逻辑答的也不错，技术面也不错基本上会给85分左右，第三阶段能回答比较好的话能给90。
如果三个阶段都满意的则是95+。第一阶段第二阶段比较满意，但第三阶段一般的给90左右。

第四点建议：没事可以多逛逛技术论坛，其实技术论坛上有不少程序员分享了他们生产实际中遇到的问题和自己的解决方案，他山之石可以攻玉。


我写这个面经是因为我要找工作了，顺便记录下来自己的一些心得笔记，文中有一些作者的个人观点或者理解免不了会有问题，欢迎大佬们交流指正。

我的面经只写技术理论和一些解决方案，不会记录一些问答内容，内容包括 mysql、jvm、多线程、redis、kafka、rabbitmq、springcloud、springboot、devops。


# java Se

## 集合 

![](2022-06-07-22-51-42.png)

![](2022-06-07-22-54-57.png)

![](2022-06-07-23-11-47.png)

|  类名称   | 作用  |
|  ----  | ----  |
| HashSet  | 为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单 |
| TreeSet  | 实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列 |
| ArrayList  | 一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组 |
| ArrayDueue  | 是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素 |
| LinkedList  | 链表+Deque |
| HsahMap  | 按哈希算法来存取键对象 |
| TreeMap  | 可以对键对象进行排序 |
| Hashtable  | 不允许键或值为 null,线程安全的Map |
| ConcurrentLinkedQueue  |  单向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全，内部基于节点实现 |
| ConcurrentLinkedDeque    |  双向向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全，内部基于节点实现 |
| PriorityQueue    |  内部基于数组实现，线程不安全的队列 |
| DelayQueue    |  延时队列，阻塞队列 |
| LinkedTransferQueue    |  一个由链表结构组成的无界阻塞队列 |
| ArrayBlockingQueue    |  有界队列，阻塞式,初始化时必须指定队列大小，且不可改变；，底层由数组实现； |
| SynchronousQueue    |  最多只能存储一个元素，每一个put操作必须等待一个take操作，否则不能继续添加元素 |一个带优先级的队列，而不是先进先出队列。 |
| Vector    |  线程安全的list |
| Stack     |  栈，继承Vector，底层为数组 |

老生常谈，hashmap扩容机制与哈希冲突算法：

在jdk1.8之前创建该对象，会创建一个长度为16的Entry[] table用来存储键值对数据。jdk1.8之后不是在构造方法创建了，而是在第一次调用put方法时才进行创建，创建Node[] table。

Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。




## 多线程

## io

## 其他

## jvm

## 并发

## spring

## springboot

## springcloud

## 中间件

## mysql

## redis
