
作者：muggle 公众号：六个核弹 wx：muggle_wx

[top]

# 开篇语

自用烤面经，勿外传

之前在公司做过一段时间面试官，公司的面试流程是：HR找简历，和候选人聊并索要简历 ---> 一面面试官筛选候选人简历 ---> 一面，记录候选人问答内容，打分 ---> 把一面记录交给研发组长，由研发组长负责二面 》 根据候选人定位职级安排三面（高职级才有三面）---> hr面，谈薪资。

在这里我分享下我做面试官的经验，公司一面二面都是线上面试，我负责的流程是一面，一般我会和另外一个小伙伴一起负责一面，因为相对而言二对一面试能给候选人带来比较大的压迫感，对一些心虚的候选人有比较好的压制力，不要小看这一点，屡试不爽。

第一点建议：从我的角度来说作为候选人一定要复习好技术点，要带着自信去面试，不要露怯。

在面试方面我们一般会提前根据候选人的项目经历问一些业务逻辑，然后根据业务中使用到的技术或设计方案进行提问，中途可能会结合我们自身类似的经历问一些问题。

第二点建议：项目经历要写好，项目经历从一定程度上对面试官的提问起到引导作用。

在问完项目相关的问题后基本上我们就会有个初步的打分了，基本上能答上来的给80分左右，答上来大部分卡壳比较多的60分，低于60分的基本上后面就是随便问问走走过场。
然后我们会问一些纯技术方面的问题，技术问题会根据候选人的技术栈进行提问，其实这个阶段也是面试官和候选人交流技术心得的阶段。
在这个阶段基本上对自己比较自信的候选人面对一些疑惑都会反过来问面试官问题，一般我们也会很乐意这种交流。这个阶段我们着重问的技术点是 redis mysql jvm，候选人如果能答上80%左右基本上就让过了。
我们问的问题基本上会尽量避免一些八股文，因为线上面试有很多候选人喜欢叫朋友帮忙百度，遇到过好几次，还有照着csdn念都念错的。

第三点建议：八股文可以背，但是要有自己的理解，把八股文的答案理解下来，而不是就纯粹的背答案。

第三阶段会问一些实践问题，这一环节更倾向于考虑对候选人是否加分。会结合候选人的项目经理问一些类似oom，高cpu使用率等事故进行提问，如果是被提前pass掉的候选人就不问这些了。
最后如果候选人项目的业务逻辑答的不是很好，但是技术面回答的还不错的我们定义为八股文选手，这种选手处于可过可不过的水平，会根据第三阶段的回答情况打80到85分。
如果候选人业务逻辑答的还可以，技术面不太行我们定义为老油条，一般是不给过的。如果业务逻辑答的也不错，技术面也不错基本上会给85分左右，第三阶段能回答比较好的话能给90。
如果三个阶段都满意的则是95+。第一阶段第二阶段比较满意，但第三阶段一般的给90左右。

第四点建议：没事可以多逛逛技术论坛，其实技术论坛上有不少程序员分享了他们生产实际中遇到的问题和自己的解决方案，他山之石可以攻玉。


我写这个面经是因为我要找工作了，顺便记录下来自己的一些心得笔记，文中有一些作者的个人观点或者理解免不了会有问题，欢迎大佬们交流指正。

我的面经只写技术理论和一些解决方案，不会记录一些问答内容，内容包括 mysql、jvm、多线程、redis、kafka、rabbitmq、springcloud、springboot、devops。


# java Se

## 集合 

![](2022-06-07-22-51-42.png)

![](2022-06-07-22-54-57.png)

![](2022-06-07-23-11-47.png)

|  类名称   | 作用  |
|  ----  | ----  |
| HashSet  | 为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单 |
| TreeSet  | 实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列 |
| ArrayList  | 一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组 |
| ArrayDueue  | 是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素 |
| LinkedList  | 链表+Deque |
| HsahMap  | 按哈希算法来存取键对象 |
| TreeMap  | 可以对键对象进行排序 |
| Hashtable  | 不允许键或值为 null,线程安全的Map |
| ConcurrentLinkedQueue  |  单向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全，内部基于节点实现 |
| ConcurrentLinkedDeque    |  双向向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全，内部基于节点实现 |
| PriorityQueue    |  内部基于数组实现，线程不安全的队列 |
| DelayQueue    |  延时队列，阻塞队列 |
| LinkedTransferQueue    |  一个由链表结构组成的无界阻塞队列 |
| ArrayBlockingQueue    |  有界队列，阻塞式,初始化时必须指定队列大小，且不可改变；，底层由数组实现； |
| SynchronousQueue    |  最多只能存储一个元素，每一个put操作必须等待一个take操作，否则不能继续添加元素 |一个带优先级的队列，而不是先进先出队列。 |
| Vector    |  线程安全的list |
| Stack     |  栈，继承Vector，底层为数组 |

老生常谈，hashmap扩容机制与哈希冲突算法：

在jdk1.8之前创建该对象，会创建一个长度为16的Entry[] table用来存储键值对数据。jdk1.8之后不是在构造方法创建了，而是在第一次调用put方法时才进行创建，创建Node[] table。

Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。

通常解决hash冲突的方法有4种：

- 开放定址法，也称为线性探测法，就是从发生冲突的那个位置开始，按照一定的次序从hash表中找到一个空闲的位置，然后把发生冲突的元素存入到这个空闲位置中。ThreadLocal就用到了线性探测法来解决hash冲突的。
- 链式寻址法，这是一种非常常见的方法，简单理解就是把存在hash冲突的key，以单向链表的方式来存储，比如HashMap就是采用链式寻址法来实现的。
- 再hash法，就是当通过某个hash函数计算的key存在冲突时，再用另外一个hash函数对这个key做hash，一直运算直到不再产生冲突。
- 建立公共溢出区， 就是把hash表分为基本表和溢出表两个部分，凡是存在冲突的元素，一律放入到溢出表中。


## JUC

JUC是java.util.concurrent包的简称。 AQS（AbstractQueuedSynchronizer）是多线程同步器，它是JUC（java.util.concurrent）包中多个组件的底层实现，比如像Lock、CountDownLatch、Semaphore等都是用到了AQS。
AQS采用了一个int类型的互斥变量state，0表示没有任务线程使用该资源，而大于等于1表示已经有线程正在持有锁资源。一个线程获取锁资源的时候，会判断state是否等于0（无锁状态），如果是，则把这个state更新为1，表示占用到锁，而这个过程中，如果多个线程同时做这样的操作，就会导致线程的安全性问题。因此AQS采用了CAS机制，来保证互斥变量state更新的原子性。

未获得到锁的线程通过Unsafe类中的park方法去进行阻塞，把阻塞的线程封装到Node节点中，按照先进先出的原则去放到一个双向链表的结构中，这个双向链表等同于一个CLH队列。当获得所得线程释放锁之后，会从这个双向链表的头部去唤醒下一个等待的线程再去竞争锁。在Node 节点中 包含了上一个节点，下一个节点 和线程状态（waitStatus），当前线程等信息。 



JUC 中的集合类：

- ConcurrentHashMap：支持多线程的分段哈希表，它通过将整个哈希表分成多段的方式减小锁粒度
- ConcurrentSkipListMap：ConcurrentSkipListMap的底层是通过跳表来实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O（logn）;
- ConCurrentSkipListSet：参考ConcurrentSkipListMap；
- CopyOnWriteArrayList：是ArrayList 的一个线程安全的变形，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的;
- CopyOnWriteArraySet：参考CopyOnWriteArrayList;
- ConcurrentLinkedQueue：cas实现的非阻塞并发队列;

JUC 中的锁：

- ReentrantLock：ReentrantLock重入锁，是实现Lock接口的一个类，它对公平锁和非公平锁都支持；它是 AQS实现的一个锁
- Semaphore：Semaphore(信号量)是对锁的扩展，锁每次只允许一个线程访问一个资源，而信号量却可以指定多个线程访问某个资源；
- ReadWriteLock：读写分离锁， 读写分离锁可以有效的减少锁竞争，读锁是共享锁，可以被多个线程同时获取，写锁是互斥只能被一个线程占有，ReadWriteLock是一个接口，其中readLock()获得读锁，writeLock()获得写锁 其实现类ReentrantReadWriteLock是一个可重入得的读写锁，它支持锁的降级(在获得写锁的情况下可以再持有读锁)，不支持锁的升级（在获得读锁的情况下不能再获得写锁）；读锁和写锁也是互斥的，也就是一个资源要么被上了一个写锁，要么被上了多个读锁，不会发生这个资即被上写锁又被上读锁的情况。
- CountDownLatch（闭锁）：一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。即，一组线程等待某一事件发生，事件没有发生前，所有线程将阻塞等待；而事件发生后，所有线程将开始执行；闭锁最初处于封闭状态，当事件发生后闭锁将被打开，一旦打开，闭锁将永远处于打开状态。
- CyclicBarrier（栅栏）：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。利用栅栏，可以使线程相互等待，直到所有线程都到达某一点，然后栅栏将打开，所有线程将通过栅栏继续执行。

JUC 中的原子类：

- AtomicBoolean:原子更新布尔类型.
- AtomicInteger:原子更新整型.
- AtomicLong:原子更新长整型.
- AtomicIntegerArray:原子更新整型数组.
- AtomicLongArray:原子更新长整型数组.
- AtomicReferenceArray:原子更新引用类型数组.
- AtomicReference:原子更新引用类型.
- AtomicStampedReference:原子更新引用类型,使用Pair存储元素值和版本号.
- AtomicMarkableReference:原子更新带有标记的引用类型.
- AtomicIntegerFieldUpdater:原子更新整型的字段的更新器.
- AtomicLongFieldUpdater:原子更新长整型的字段的更新器.
- AtomicReferenceFieldUpdater:原子更新引用类型字段的更新器.


## Runtime 类

Runtime类包括：查看系统内存、终止JVM虚拟机、运行系统程序、使用关闭钩子。
API列表：
![](2022-06-08-15-20-29.png)

## unsafe 类
Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。

Unsafe 对象不能直接通过 new Unsafe() 或调用 Unsafe.getUnsafe() 获取。getUnsafe 被设计成只能从引导类加载器（bootstrap class loader）加载。直接调用 Unsafe.getUnsafe() 方法会抛出 SecurityException 异常。想要通过Unsafe.getUnsafe()方式获需要取通过Java命令行命令-Xbootclasspath/a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。
```
java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径 
```
还可以通过反射获取：
```
private static Unsafe reflectGetUnsafe() {
    try {
      Field field = Unsafe.class.getDeclaredField("theUnsafe");
      field.setAccessible(true);
      return (Unsafe) field.get(null);
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      return null;
    }
}
```
unsafe 功能：

![](2022-06-08-15-36-02.png)

```
//分配内存, 相当于C++的malloc函数
public native long allocateMemory(long bytes);
//扩充内存
public native long reallocateMemory(long address, long bytes);
//释放内存
public native void freeMemory(long address);
//在给定的内存块中设置值
public native void setMemory(Object o, long offset, long bytes, byte value);
//内存拷贝
public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等
public native Object getObject(Object o, long offset);
//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等
public native void putObject(Object o, long offset, Object x);
//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）
public native byte getByte(long address);
//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）
public native void putByte(long address, byte x);

/**
	*  CAS
  * @param o         包含要修改field的对象
  * @param offset    对象中某field的偏移量
  * @param expected  期望值
  * @param update    更新值
  * @return          true | false
  */
public final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);

public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);
  
public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);

//取消阻塞线程
public native void unpark(Object thread);
//阻塞线程
public native void park(boolean isAbsolute, long time);
//获得对象锁（可重入锁）
@Deprecated
public native void monitorEnter(Object o);
//释放对象锁
@Deprecated
public native void monitorExit(Object o);
//尝试获取对象锁
@Deprecated
public native boolean tryMonitorEnter(Object o);

//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的
public native long staticFieldOffset(Field f);
//获取一个静态类中给定字段的对象指针
public native Object staticFieldBase(Field f);
//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false。
public native boolean shouldBeInitialized(Class<?> c);
//检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。
public native void ensureClassInitialized(Class<?> c);
//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者
public native Class<?> defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);
//定义一个匿名类
public native Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches);

//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量
public native long objectFieldOffset(Field f);
//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等
public native Object getObject(Object o, long offset);
//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等
public native void putObject(Object o, long offset, Object x);
//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义
public native Object getObjectVolatile(Object o, long offset);
//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义
public native void putObjectVolatile(Object o, long offset, Object x);
//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效
public native void putOrderedObject(Object o, long offset, Object x);
//绕过构造方法、初始化代码来创建对象
public native Object allocateInstance(Class<?> cls) throws InstantiationException;
```
## io
![](2022-06-08-15-52-08.png)

nio有四个很重要的类：Selector，Channel，Buffer，Charset。
- Channel通过节点流的getChannel()方法来获得，成员map()用来将其部分或全部数据映射为Buffer，成员read()、write()方法来读写数据，而且只能通过Buffer作为缓冲来读写Channel关联的数据。
- Buffer是一个缓冲区，它是一个抽象类，常用的子类:ByteBuffer,MappedByteBuffer,CharBuffer,DoubleBuffer,FloatBuffer,IntBuffer,LongBuffer,ShortBuffer等，通过它可以用来装入数据和输出数据。当向Buffer写入数据后，在读取Buffer中数据之前应该调用flip()方法来设置Buffer中的数据位置信息，读取Buffer中数据之后应该调用clear()方法来清空原来的数据位置信息。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。
- Charset可以将Unicode字符串（CharBuffer）和字节序列（ByteBuffer）相互转化。
- Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel。通过调用Selector.open()方法创建一个Selector，将Channel注册到Selector上。

buffer 原理详解：

缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。它的三个属性capacity,position和limit就是描述这块内存的了。capacity可以简单理解为这块内存的大小；写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1. 当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。limit表示你最多能读（写）多少数据。

NIO 零拷贝：
正常io会将操作的io数据复制到jvm虚拟机中然后操作。而零拷贝则是直接操作堆外内存。从操作系统层面的体现就是一个数据如果不采用零拷贝则数据需要从磁盘拷贝到内核空间，再从内核空间拷到用户空间（JVM），然后对数据处理，再将数据拷贝到内核空间(操作系统)，内核空间再拷贝到磁盘或者网卡内存，通过网络发送出去。

## 多线程

1）同步和异步

同步和异步通常来形容一次方法的调用。同步方法一旦开始，调用者必须等到方法结束才能执行后续动作；异步方法则是在调用该方法后不必等到该方法执行完就能执行后面的代码，该方法会在另一个线程异步执行，异步方法总是伴随着回调，通过回调来获得异步方法的执行结果；

2） 并发和并行

很多人都将并发与并行混淆在一起，它们虽然都可以表示两个或者多个任务一起执行，但执行过程上是有区别的。并发是多个任务交替执行，多任务之间还是串行的；而并行是多个任务同时执行，和并发有本质区别。 对计算机而言，如果系统内只有一个cpu，而使用多进程或者多线程执行任务，那么这种情况下多线程或者多进程就是并行执行，并行只可能出现在多核系统中。当然，对java程序而言，我们不必去关心程序是并行还是并发。

3） 临界区

临界区表示的是多个线程共享但同时只能有一个线程使用它的资源。在并行程序中临界区资源是受保护的，必须确保同一时刻只有一个线程能使用它。

4） 阻塞

如果一个线程占有了临界区的资源，其他需要使用这个临界区资源的线程必须在这个临界区进行等待——线程被挂起，这种情况就是发生了阻塞——线程停滞不前。

5） 死锁\饥饿\活锁

死锁就是多个线程需要其他线程的资源才能释放它所拥有的资源，而其他线程释放这个线程需要的资源必须先获得这个线程所拥有的资源，这样造成了矛盾无法解开；

活锁就是两个线程互相谦让资源，结果就是谁也拿不到资源导致活锁；就好比过马路，行人给车让道，车又给行人让道，结果就是车和行人都停在那不走。

饥饿就是，某个线程优先级特别低老是拿不到资源，导致这个线程一直无法执行

6） 并发级别

并发级别分为阻塞，无饥饿，无障碍，无锁，无等待几个级别；根据名字我们也能大概猜出这几个级别对应的什么情形；阻塞，无饥饿和无锁都好理解；我们说一下无障碍和无等待；

无障碍：无障碍级别默认各个线程不会发生冲突，不会互相抢占资源，一旦抢占资源就认为线程发生错误，进行回滚。

无等待：无等待是在无锁上的进一步优化，限制每个线程完成任务的步数；

7） 并行的两个定理

加速比：加速比=优化前系统耗时/优化后系统耗时

Amdahl定理： 加速比=1/[F+(1-F)/n] 其中 n表示处理器个数 ，F是程序中只能串行执行的比例——串行率；由公式可知，想要以最小投入，得到最高加速比即 F+(1-F)/n取到最小值，F和n都对结果有很大影响，在深入研究就是数学问题了；

Gustafson定律： 加速比=n-F(n-1)，这两定律区别不大，都体现了单纯的减少串行率，或者单纯的加CPU都无法得到最优解。

8）volatile关键字
 volatile保证可见性的意义：
 
 CPU中存在一个高速缓存以提高cpu对数据的计算速度。将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中。cpu一般书多核的，意味着在多线程的环境下，cpu内核之间的高速缓存可能存在不一致的情况，从而导致运算错误。为了高速缓存的一致性，就有了缓存一致性的协议，主流的缓存一致性协议就是MESI 协议（写入失效协议）。M——Modified 修改状态，E——Exclusive 独享状态，S——Shared共享状态，I——Invalid 失效状态。
 
 大体上来说就是当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

volatile 关键字就是强制让cpu 保证当前数据的缓存一致。

volatile禁止指令重排的意义：

对一个操作而言指令是按一定顺序执行的，但编译器为了提高程序执行的速度，会重排程序指令；cpu在执行指令的时候采用的是流水线的形式，上一个指令和下一个指令差一个工步。比如A指令分三个工步：1. 操作内存a，2.操作内存b，3.操作内存c；现假设有个指令B操作流程和A一样，那么先执行指令A在执行指令B时间全利用上了，中间没有停顿等待；但如果有三个这样的指令在流水线上执行：a>b>c，b>e>c，c>e>a；这样的指令顺序就会发生等待降低了CPU的效率，编译器为了避免这种事情发生，会适当优化指令的顺序进行重排。

指令重排序可能会导致程序执行步骤错误，java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。

内存屏障就是一类同步屏障指令，是CPU或者编译器在对内存随机访问的操作中的一个同步点，只有在此点之前的所有读写操作都执行后才可以执行此点之后的操作。

9）happen-before
为了明确定义多线程场景下重排序的问题，Java引入了JMM(Java Memory Model)，也就是Java内存模型。如果有了重排序就会出现原子性，可见性，有序性的问题，但是性能会提升。所以Java内存模型不是真实存在的，而是一套规范，可以方便的使开发者在运行效率和程序开发的方便性之间找到一个平衡点。

一方面要让CPU和编译器可以灵活的进行重排序，另一方面也要告诉开发者，在什么情况下什么样的重排序不需要感知，需要感知什么样的重排序并作出处理。

为了描述这个规范，JMM引入了happen-before，使用happen-before描述两个操作之间的内存可见性。

简单来说，happen-before的意思就是，如果 操作A happen-before 操作B，那么操作A的执行结果必须对操作B可见。

happen-before的七条原则:

- 单线程规则：同一个线程中的每个操作都happens-before于出现在其后的任何一个操作。
- 对一个监视器的解锁操作happens-before于每一个后续对同一个监视器的加锁操作。
- 对volatile字段的写入操作happens-before于每一个后续的对同一个volatile字段的读操作。
- Thread.start()的调用操作会happens-before于启动线程里面的操作。
- 一个线程中的所有操作都happens-before于其他线程成功返回在该线程上的join()调用后的所有操作。
- 一个对象构造函数的结束操作happens-before与该对象的finalizer的开始操作。
- 传递性规则：如果A操作happens-before于B操作，而B操作happens-before与C操作，那么A动作happens-before于C操作。

10）线程池
线程的生命周期五个阶段：创建、就绪、运行、阻塞、终止。
Executors 下的线程池:
- newFixedThreadPool(int nThreads) ：创建固定数目线程的线程池；
- newCachedThreadPool：创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中；
- newSingleThreadExecutor：创建一个单线程化的Executor；
- newScheduledThreadPool：创建一个支持定时及周期性的任务执行的线程池。

```
public class Test implements Runnable{
	int i=0;
	public Test(int i){
		this.i=i;
	}
	public void run() {
		System.out.println(Thread.currentThread().getName()+"====="+i);
	}
    public static void main(String[] args) throws InterruptedException {
		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
		for(int i=0;i<10;i++){
			cachedThreadPool.execute(new Test(i));
			Thread.sleep(1000);
		}
	}
}
```

ThreadPoolExecutor中参数详解:

- corePoolSize：核心线程数，也是线程池中常驻的线程数，线程池初始化时默认是没有线程的，当任务来临时才开始创建线程去执行任务
- maximumPoolSize：最大线程数，在核心线程数的基础上可能会额外增加一些非核心线程，需要注意的是只有当workQueue队列填满时才会创建多于corePoolSize的线程(线程池总线程数不超过maxPoolSize)
- keepAliveTime：非核心线程的空闲时间超过keepAliveTime就会被自动终止回收掉，注意当corePoolSize=maxPoolSize时，keepAliveTime参数也就不起作用了(因为不存在非核心线程)；
- unit：keepAliveTime的时间单位
- workQueue：用于保存任务的队列，可以为无界、有界、同步移交三种队列类型之一，当池子里的工作线程数大于corePoolSize时，这时新进来的任务会被放到队列中
- threadFactory：创建线程的工厂类，默认使用Executors.defaultThreadFactory()，也可以使用guava库的ThreadFactoryBuilder来创建
- handler：线程池无法继续接收任务(队列已满且线程数达到maximunPoolSize)时的饱和策略，取值有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy

11）锁相关概念

- 阻塞锁：当一个线程获得锁，其他线程就会被阻塞挂起，直到抢占到锁才继续执行，这样会导致CPU切换上下文，切换上下文对CPU而言是很耗费时间的
- 非阻塞锁：当一个线程获得锁，其他线程直接跳过锁资源相关的代码继续执行，就是非阻塞锁
- 自旋锁：当一个线程获得锁，其他线程则在不停进行空循环，直到抢到锁，这样做的好处是避免了上下文切换
- 可重入锁：也叫做递归锁，当一个线程外层函数获得锁之后 ，内层递归函数仍然可以该锁的相关代码，不受影响。
- 互斥锁：互斥锁保证了某一时刻只能有一个线程占有该资源。
- 读写锁：将代码功能分为读和写，读不互斥，写互斥；
- 公平锁/非公平锁：公平锁就是在等待队列里排最前面的的先获得锁，非公平锁就是谁抢到谁用；
- 重量级锁/轻量级锁/偏向锁：使用操作系统“Mutex Lock”功能来实现锁机制的叫重量级锁，因为这种锁成本高；轻量级锁是对重量级锁的优化，提高性能；偏向锁是对轻量级锁的优化，在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。
- 乐观锁
- 悲观锁

锁优化的常用方法：
- 控制锁的粒度
- 控制锁的持有时间
- 锁分离

synchronized 原理：

Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的互斥锁（Mutex Lock）来实现的，这种依赖于操作系统互斥锁（Mutex Lock）所实现的锁我们称之为“重量级锁”。JDK 1.6之后对 synchronized 进行了优化，并不是直接对，共享资源进行上锁而是有一个锁膨胀的过程。

单线程的时候是偏向锁，如果有两个线程，会升级成轻量级锁（自旋锁、cas），如果线程很多的情况下，就会再次升级为重量级锁；

偏向锁的时候只有一个线程，当有别的线程进行竞争的时候，首先会在每个线程里都生成自己独立的一个LockRecord（锁记录，简称LR），抢线程的时候使用cas的方式将LR的指针更新到markword里面，成功刷进去了则表示抢到了锁，没抢到的会一直在那自旋，直到抢到锁为止。当轻量级锁自旋到达一定条件就会升级成重量级锁，这个自旋次数是jvm自己决定的。

cas ：
cas(比较替换)：无锁策略的一种实现方式，过程为获取到变量旧值（每个线程都有一份变量值的副本），和变量目前的新值做比较，如果一样证明变量没被其他线程修改过，这个线程就可以更新这个变量，否则不能更新；通俗的说就是通过不加锁的方式来修改共享资源并同时保证安全性。

cas 的aba 问题：
一个线程把数据A变成了B，然后又重新变成了A，此时另一个线程读取该数据的时候，发现A没有变化，就误认为是原来的那个A，但是此时A的一些属性或状态已经发生过变化，另外一个线程应该获取锁失败的，结果却成功了。解决方案为添加版本号，`AtomicStampedReference` 使用的就是带版本号的cas,它这里的版本号叫stamp：
```
/**
     * Atomically sets the value of both the reference and stamp
     * to the given update values if the
     * current reference is {@code ==} to the expected reference
     * and the current stamp is equal to the expected stamp.
     *
     * @param expectedReference the expected value of the reference
     * @param newReference the new value for the reference
     * @param expectedStamp the expected value of the stamp
     * @param newStamp the new value for the stamp
     * @return {@code true} if successful
     */
    public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            expectedStamp == current.stamp &&
            ((newReference == current.reference &&
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
```

## 对象

对象都由对象头(header)、对象的实例数据区(InstanceData)和对齐填充字节(Padding)这三部分组成。

对象头的组成：
- Mark Word：记录对象和锁的有关信息。MarkWord通常都是 32 bit位大小。会保存一些分代年龄、无锁状态下对象的HashCode、偏向锁的线程ID、轻量级锁指向栈中锁记录的指针、指向重量级锁的指针、锁的标志位等内容。
- 指向类的指针：大小也通常为32bit，它主要指向类的数据，也就是指向方法区中的位置。
- 数组长度：只有数组对象才有，在32位或者64位JVM中，长度都是32bit。

逃逸分析：

当一个对象在方法中被定义后，它可以能被外部方法所引用。作为调用参数传递到其它地方种，称为方法逃逸。赋值给类变量或者可以在其它线程中访问的实例变量，称为线程逃逸。

一般在java程序中，new的对象是分配在堆空间中的，但是实际的情况是，大部分的new对象会进入堆空间中，而并非是全部的对象，有部分对象是可以分配在栈上以提高效率。

逃逸分析的目的：

- 栈上分配：一个方法中的对象，若该对象没有发生逃逸，则可以将这个对象分配在栈上
- 消除同步：线程同步的代价是相当高的，同步带来的后果是降低了并发性和程序性能。逃逸分析以判断某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么该对象的同步操作就可以转化为没有同步的操作，这样可以大大提高并发性能。
- 标量替换：java虚拟机中的原始数据类型(int,long等)都不能在进一步分解，他们就可以成为标量。相对的，如果一个数据可以继续分解，那么他成为聚合量，java中最典型的聚合量就是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个这个对象是可以分解的，那么程序真正执行的时候可能不创建这个对象，而改为直接创建它的若干个被这个方法能够使用到的成员变量来代替。拆散后的变量便可以被单独的分析与优化，可以分别分配在栈帧或者寄存器上，原来的对象就不需要整体被分配在堆中。

## spi

SPI是service provider interface的简写，是基于接口的编程＋策略模式＋配置文件组合实现的动态加载类机制，目的是解耦，增加可扩展性。
spi机制是这样的：读取META-INF/services/目录下的元信息，然后ServiceLoader根据信息加载对应的类，你可以在自己的代码中使用这个被加载的类。要使用Java SPI，需要遵循如下约定：

- 当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；
- 接口实现类所在的jar包放在主程序的classpath中，主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；
- SPI的实现类必须携带一个不带参数的构造方法；

spi 在框架中的使用包括 spring、dubbo、slf4j、jdbc。

## jdk tool 

1）jar
jar 指令是对jar包进行操作的指令，包括打包、拆包、替换等操作：
```
/* 1. 默认打包 */
// 生成的test.jar中就含test目录和jar自动生成的META-INF目录（内含MAINFEST.MF清单文件）
jar -cvf test.jar test

/* 2. 查看包内容 */
jar -tvf test.jar

/* 3. 解压jar包 */
jar -xvf test.jar

/* 4. 提取jar包部分内容 */
jar -xvf test.jar test\test.class

/* 5. 追加内容到jar包 */
//追加MAINFEST.MF清单文件以外的文件，会追加整个目录结构
jar -uvf test.jar other\ss.class

//追加清单文件，会追加整个目录结构(test.jar会包含META-INF目录)
jar -uMvf test.jar META-INF\MAINFEST.MF

/* 6. 创建自定义MAINFEST.MF的jar包 */
jar -cMvf test.jar test META-INF

// 通过-m选项配置自定义MAINFEST.MF文件时，自定义MAINFEST.MF文件必须在位于工作目录下才可以
jar -cmvf MAINFEST.MF test.jar test
```

2）javap

javap 指令可以将我们的字节码文件转汇编和转操作码。实际上很多代码想真正的搞懂其底层原理都需要通过阅读操作码或者汇编才能明白，比如volitail,this等这些关键字底层原理。

执行指令解析 class 文件：
```
javap -v -l -p -s -sysinfo  -constants Test.class
```
解析出的class 文件由以下几部分构成：

- `Constant pool`：编译时常量池
- ()V 表示无参的无返回值的方法描述符
- aload_0 从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈
- invokestatic invokespecial invokeinterface 分别指调用静态方法 私有方法 接口方法。
- 当代码中使用到 `sychornized` 关键字，会看到被解析的操作码内容中包含 `monitorenter` 和 `monitorexit` 两个指令，分别表示获取对象监听器，释放对象监听器。

3）jps

jps是一个可以列出正在运行的Java虚拟机的进程信息的命令行工具，它可以显示Java虚拟机进程的执行主类名称、本地虚拟机唯一ID等信息。另外，jps命令只能显示它有访问权限的Java进程的信息。


4）jstack
jstack 是获取线程快照的指令:
```
jstack pid |grep tid -A 30
```
一般我们会关注当前线程的运行状态以判断是否发生死锁或者其他异常情况，线程快照中线程有以下几种状态：
- NEW,未启动的。不会出现在Dump中。
- RUNNABLE,在虚拟机内执行的。
- BLOCKED,受阻塞并等待监视器锁。
- WATING,无限期等待另一个线程执行特定操作。
- TIMED_WATING,有时限的等待另一个线程的特定操作。
- TERMINATED,已退出的。

在 jvm 发生异常，如内存溢出等情况时会自动生成Javacore文件，这个文件也是线程快照文件，也可以通过该指令进行分析：
```
jstack /usr/bin/java core.xxx
```

在实战调优篇具体介绍。

5) jmap
jmap是获取内存快照的指令。
```
// option：jmap命令的可选参数。如果没有指定这个参数，jinfo命令会显示Java虚拟机进程的内存映像信息
jmap [options] pid
```

option 参数：

- -heap：被指定的垃圾回收算法的信息，堆的配置信息，堆的内存空间使用信息
- -histo：显示Java堆中对象的统计信息，包括：对象数量、占用内存大小(单位：字节)和类的完全限定名
- -clstats：显示Java堆中元空间的类加载器的统计信息
- -finalizerinfo：显示在F-Queue中等待Finalizer线程执行finalize方法的对象。
- -dump：生成Java虚拟机的堆转储快照dump文件

如果我们希望在jvm 发生oom的时候生成内存快照，需要在jar启动参数上加上指令：
```
-XX:+HeapDumpOnOutOfMemoryError
```

# jvm

## JMM
 JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。 JMM可以理解为是一个规范，一个抽象概念，并不真实存在。

 ![](2022-06-08-22-38-26.png)

 前文我们提到过的 volatile 关键字保证变量的可见性的问题，也可以在JMM 中找到答案，这里的本地内存就可以看做是高速缓存，通过MESI保证数据可见性。

## JVM 组成

![](2022-06-08-22-45-58.png)

1）java堆区

java堆是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，该区域在虚拟机启动的时候创建。这个区域的唯一目的就是存放对象实例。java堆是垃圾收集器工作的主要区域，由于垃圾收集器基本都采用分代收集的算法，所以java堆从垃圾收集器的角度来划分可以细分为新生代和老年代；从内存分配的角度来看，线程共享的java堆可能划分出多个线程私有的分配缓冲区。
   
java堆区可以是物理上不连续的内存空间，只要逻辑上是连续的即可；一般而言我们的虚拟机java堆内存不是固定大小的，是可以扩展的。如果在堆中没有足够内存分配给对象实例，并且堆内存无法再扩展时，虚拟机将会抛出OutOfMemoryError异常。

2） 方法区

 方法区与java堆区一样是各个线程共享的内存区域，这个区域存储了类信息、常量、静态变量等数据。java虚拟机规范中把方法区描述为堆得一部分逻辑，它又有一个名字——非堆，目的是与普通java堆进行区分。相对而言垃圾收集器在这个区域很少活动，因此一部分人把这个区域叫做“永久代”。这个区域的内存回收目标主要是针对常量池的回收和类型的卸载，然而类型卸载的条件是很苛刻的。该区域和和java堆区一样，当内存不够分配时会抛出OutOfMemoryError.

3）运行时常量池
运行时常量池是方法区的一部分；一个Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是编译时常量池，用于存放编译期生成的常量。编译时常量池在类被加载后会放入方法区的运行时常量池中。与编译期常量池不同的是，运运行时常量池是动态的，运行期间产生的新的常量也会被放入这个区域，如：String类的intern()方法。

4）本地方法栈(线程私有)
登记native方法，在Execution Engine执行时加载本地方法库

5）程序计数器(线程私有)
就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

6）Java栈（线程私有）：Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致。

## 对象

1）对象的创建

在语言层面上，创建一个对象通常是通过new关键字来创建，在虚拟机中遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过；如果没有的话就会先加载这个类；类加载检查完后，虚拟机将会为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，在堆中为对象划分一块内存出来。

   虚拟机给对象分配内存的方式有两种——“指针碰撞”的方式和“空闲列表”的方式。如果java堆内存是绝对规整的，所有用过的内存放在一边，未使用的内存放在另一边，中间放一个指针作为指示器，那分配内存就只是把指针向未使用区域挪一段与对象大小相等的距离；这种分配方式叫指针碰撞式：

![](2022-06-08-22-52-44.png)

我们知道，堆内存随时都可能被垃圾收集器回收的，当内存被回收后堆内存就可能不是连续的了，所以当采用指针碰撞的方式时，垃圾收集器必须有内存整理的功能，能对垃圾回收后的零散内存进行整理。而空闲列表的方式则不需要垃圾收集有这个功能，采用这种方式时虚拟机会维护一张表，用于记录那些内存是可用的，当需要分配内存时就从表中找出一块足够的内存进行分配，并记录在表上。

   内存分配完成后，虚拟机需要将分配到的内存空间都初始化；接下来虚拟机会对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希值、对象的GC的分代年龄等信息。这些信息存在对象的对象头之中。完成这些工作后，从虚拟机的角度来看一个新的对象就产生了，但从程序的角度来看对象创建才刚刚开始，对象尚未执行初始化方法，各个字段都还未赋值，接下来会执行初始化方法，只有在执行初始化方法后，一个真正可用的对象才算是被创建。

2）对象的内存

参考 javase 部分的 对象 章节

3）对象的访问定位

 建立对象是为了使用对象，我们的java程序需要通过栈上的reference来操作堆上的对象。通过reference来访问对象的方法有两种——使用句柄和直接指针。在虚拟机执行一个方法时，虚拟机栈 中会为方法分配一个 局部变量表，一个操作数栈；局部变量表是用于保存函数的参数以及局部变量的，其保存的类型有boolean、byte、char、short、int、float、reference和returnAddress八种；方法在执行的过程中，会有各种各样的字节码指令往操作数栈中执行入栈和出栈操作，完成数据的运算。基本数据类型直接存储到变量表中。那reference是如何找到引用的对象的呢？

   如果使用句柄的话，那么会在java堆中划分一块内存来作为句柄池，reference中存储的是句柄的地址，而句柄中包含了对象的具体地址信息：

![](2022-06-08-22-56-38.png)

 如果使用直接指针访问，那么java堆对象的布局则：
![](2022-06-08-22-57-13.png)

## 垃圾收集器

java内存在运行时被分为多个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程生成和销毁；每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，在这几个区域内就不需要过多考虑回收问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而堆区就不一样了，我们只有在程序运行的时候才能知道哪些对象会被创建，这部分内存是动态分配的，垃圾收集器主要关注的也就是这部分内存。

** 垃圾收集算法 **：

1）引用计数算法

引用计数算法是最初垃圾收集器采用的算法，也是相对简单的一种算法，其原理是：给对象中添加一个引用计数器，每当有一个地方引用它的时候这个计数器就加一；当引用失效，计数器就减一；任何时刻计数器为0则该对象就会被垃圾收集器回收。这种算法的缺点是当对象之间相互循环引用的时候，对象将永远不会被回收。

2）可达性分析算法

可达性分析算法是使用比较广泛的算法。这个算法的基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称作引用链；当一个对象和GC oots之间不存在引用链的时候，这个对象将被回收；也就是说一个存活的对象向上追溯它的引用链，其头部必然是GC Roots,如果不是将被回收。在虚拟机中可以作为GC Roots的可以是：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象，本地方法栈中Native方法引用的对象；在堆区一个存活的对象被这些对象所直接引用或间接引用(引用又分为强引用、软引用、弱引用、、虚引用，引用强调依次降低，感兴趣的可以详细了解一下)。    当一个对象的引用链中没有GC Roots的时候并不会被马上回收，第一次他会被标记并筛选，当对象没有覆盖finalize()方法或该方法已经被虚拟机调用过，那么它会被放入一个叫做F-Queue的队列中等待被虚拟机自动回收；否则虚拟机会执行finalize()方法，对象内存自然被回收掉。

** 垃圾收集器算法 **：

1）标记-清除算法

标记-清除算法是最基础的算法，算法分为标记和清除两个阶段，首先标记出要清除的对象，在标记完后统一回收所有被标记的对象，标记方式为j《jvm系列之垃圾收集器》里面所提到的。这种算法标记和清除两个过程效率都不高；并且在标记清除后，内存空间变得很零散，产生大量内存碎片。当需要分配一个比较大的对象时有可能会导致找不到足够大的内存。

2）清除-复制算法：
为了解决标记清除效率低的问题，出现了复制算法；这种算法将内存划分为大小相等的两块内存，只使用其中一块。当这一块内存使用完了就将存活的对象复制到另一块上面去，然后把已使用的内存空间一次性清理掉，这种方法不必考虑内存碎片的情况，运行高效，实现简单。缺点是浪费了一半的内存。

3）标记-整理算法

复制收集算法在对象存活率较高的时候就要进行较多的复制操作，导致效率变低。而且老年代很少会有内存回收，对老年代而言，复制算法做了大量的无用功。针对复制算法存在的的问题，有人提出了标记-整理算法。标记过程和标记-清除算法过程一样，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一方移动，整理内存，然后再进行清理。

4）分代收集算法

分代收集算法思路是根据对象存活周期不同将内存划分为几块。一般是分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中每次收集时都会回收很多内存，选用高效率的复制算法，并且只需要预留少量的复制空间，用于复制存活对象。老年代中因为对象存活率高，采用标记-整理或标记清理算法节省内存空间提高清理效率。

** 各版本垃圾收集器一览 **：

| 收集器名称        | 区  域  | 说明  |
| ----------------- | :----------------: | -----------------------------------------------------------: |
| Serial            |    新生代     | 单线程，GC时必须停止其它线程直到收集结束；JVM运行在client模式下新生代的默认收集器，简单有效；采用复制算法 |
| ParNew            |    新生代     | Serial收集的多线程版，保留Serial的参数控制，算法等，暂停所有用户线程，采用复制算法；JVM运行在server的首先的新生代收集器；只有它能和CMS配合工作 |
| Parallel Scavenge |    新生代     | 采用复制算法，并行的多线程收集器，与ParNew不同的是，关注点不是停顿时间，而是可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。可设置最大GC时间和吞吐量大小等参数，也可以让JVM自适应调整策略 |
| CMS               |    新生代     | concurrent Mark Sweep，已获取最短回收停顿为目标，大部分的互联网站及服务端采用的方式，标记-清除算法 |
| G1                | 新生代/老年代 |                   收集器最前沿版本，JDK 1.7，代替CMS的新产品 |
| Serial Old（MSC） |    老年代     | Serial的老年版，单线程收集器，采用标记-整理算法，主要是client模式的JVM使用 |
| Parallel Old      |    老年代     |              Parallel Scavenge的老年版，多线程，标记整理算法 |

** Stop The World **

我们看到新生代的垃圾收集器都要必须停止其它线程，新一代的垃圾收集器也只是尽量减少这个停顿时间，这个停顿时间被称之为 Stop The World，而作为单线程的Serial 垃圾收集器这一点最为明显。

## 类加载器



## jar 的结构及其运行原理

## JVM 参数

# spring

# springboot

# springcloud

# zookeeper

# kafka

# rabbitMQ

# docker

# k8s

# es

# mysql

# redis

# linux 
